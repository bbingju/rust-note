#+TITLE: Rust Note
#+AUTHOR: Phil Hwang
#+EMAIL: pjhwang@gmail.com

#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+STARTUP: show2levels

#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]
#+LATEX_HEADER: \usepackage{kotex}
#+LATEX_HEADER: \usepackage{a4wide}
#+LATEX_HEADER: \usepackage{listings}
# #+LATEX_HEADER: \usepackage{minted}
# #+LaTeX_HEADER: \setmainhangulfont{HCR Batang LVT}
#+LATEX_HEADER: \setmainhangulfont{Noto Sans CJK KR}

* 개발환경

- 간단한 코드 테스트는 [[https://play.rust-lang.org/][Rust Playground]]에서 할 수 있다.
- 프로그래밍에 필요한 여러 부가정보는 [[https://forge.rust-lang.org/index.html][Rust Forge]]에서 확인할 수 있다.

** Toolchains

*** Command Line Tools

유닉스 계열 운영체제는 다음과 같이 [[https://static.rust-lang.org/rustup/rustup-init.sh][rustup-init.sh]] 스크립트를 내려받은 후 실행시켜 설치할 수 있다.

#+ATTR_LATEX: :options frame=single
#+begin_src shell
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
#+end_src

이 방법으로 플랫폼에 맞는 =rustup= 명령을 설치할 수 있다. =rustup= 은 일종의 패키지 매니저이며, 이것을 통해 실제 Rust용 툴체인들을 설치할 수 있다.

**** =rustup=

설치된 패키지들을 업데이트하려면 다음과 같이 명령한다.

#+begin_src shell :results output :exports both :options frame=single
  rustup update
#+end_src

#+RESULTS:
: 
:   stable-x86_64-unknown-linux-gnu unchanged - rustc 1.65.0 (897e37553 2022-11-02)
: 


로컬로 문서를 보고 싶다면 다음과 같이 명령한다.

#+begin_src shell
  rustup doc
#+end_src

#+RESULTS:

** Editors

*** Emacs

Emacs로 Rust 언어를 프로그래밍 하는 기본적인 방법은 [[https://github.com/rust-lang/rust-mode][rust-mode]] 을 설치하는 것이다. 필요할 경우, [[https://emacs-lsp.github.io/lsp-mode/page/lsp-rust-analyzer/][LSP Mode]]나 [[https://emacs-tree-sitter.github.io/][tree-sitter]]를 고민해 볼 수 있다.

* Data Types

- Scalar와 compound로 나뉨.
- Scalar는 한개짜리 값을 의미하는데, integers, floating-point numbers, Booleans, 문자열이 여기에 속함.
- Integer type에 ~isize~, ~usize~ 라는 것이 있음.
- Integer literal은 다음과 같이 표기함

  #+NAME: Integer Literals in Rust
  | Number literals  | Example       |
  |------------------+---------------|
  | Decimal          | =98_222=      |
  | Hex              | =0xff=        |
  | Octal            | =0o77=        |
  | Binary           | =0b1111_0000= |
  | Byte (~u8~ only) | =b'A'=        |


** Tuple

Tuple은 괄호'~()~'를 사용한다.

#+begin_src rust results: output :exports both
  fn main() {
      let empty_tuple = ();		// 빈 투플
      let my_tuple = ( 23, "test tuple", vec![34, 23, 9] );

      println!("empty tuple: {:?}, my_tuple.0: {:}, my_tuple.1: {:?}",
               empty_tuple, my_tuple.0, my_tuple.1);
  }

#+end_src

#+RESULTS:
: empty tuple: (), my_tuple.0: 23, my_tuple.1: "test tuple"

** Enums
Enums는 C/C++와 같이 표현된다.

#+begin_src rust
  enum IpAddrKind {
      V4,
      V6,
  }
#+end_src

그리고 이것을 쓰는 방식은 아래와 같다.

#+begin_src rust
  let four = IpAddrKind::V4;
  let six = IpAddrKind::V6;
#+end_src

*팁*: ~use~ 문을 써서 버거로움을 줄일 수 있다.

#+begin_src rust
  use IpAddrKind::*;

  let four = V4;
  let six = V6;
#+end_src


함수의 인자는 다른 변수를 다룰 때와 같이 사용할 수 있다.

#+begin_src rust
  fn route(ip_kind: IpAddrKind) {}
#+end_src


여기서 우리가 두 주소체계를 모두 표현하는 하나의 구조체를 만든다고 가정하고 C 스타일로 정의한다면 아마 다음과 같이 할 수 있을 것이다.

#+begin_src rust
  enum IpAddrKind {
      V4,
      V6,
  }

  struct IpAddr {
      kind: IpAddrKind,
      address: String,
  }

  let home = IpAddr {
      kind: IpAddrKind::V4,
      address: String::from("127.0.0.1"),
  };

  let loopback = IpAddr {
      kind: IpAddrKind::V4,
      address: String::from("::1"),
  };
#+end_src

하지만 Rust에서는 이것을 enum 만으로 더 간편하게 표시할 수 있다.

#+begin_src rust
  enum IpAddr {
      V4(String),
      V6(String),
  }

  let home = IpAddr::V4(String::from("127.0.0.1"));

  let loopback = IpAddr::V6(String::from("::1"));
#+end_src

게다가 Enum에서 변수 타입을 개별로 설정할 수 있어서 이런 경우엔 struct를 쓰는 것보다 편하다.

#+begin_src rust
  enum IpAddr {
      V4(u8, u8, u8, u8),
      V6(String),
  }

  let home = IpAddr::V4(127, 0, 0, 1);

  let loopback = IpAddr::V6(String::from("::1"));
#+end_src

** Structs

구조체를 다음과 같이 정의 한다.

#+begin_src rust
  struct User {
      active: bool,
      username: String,
      email: String,
      sign_in_count: u64,
  }
#+end_src

사용은 이렇게 한다.

#+begin_src rust
  fn main() {
      let user1 = User {
          email: String::from("someone@example.com"),
          username: String::from("someusername123"),
          active: true,
          sign_in_count: 1,
      };
  }
#+end_src

구조체 멤버를 /field/ 라고 하는데, 접근은 C 계열과 같이 ~.~ 표기법을 이용한다. 필드의 값을 바꾸고 싶다면 구조체를 ~mut~ 하게 선언해야 한다. 개별 필드별로 mutable 하게 만들 수는 없음을 주의. 그래서 구조체를 항상 immutable 하게 만들고 싶다면 아래와 같이 builder 함수를 만들어 이용하는 방법이 있다.

#+begin_src rust
  fn build_user(email: String, username: String) -> User {
      User {
          email: email,
          username: username,
          active: true,
          sign_in_count: 1,
      }
  }
#+end_src


*** 필드 짧게 만들기

위 구조체는 다음과 같이 줄일 수 있다.

#+begin_src rust
  fn build_user(email: String, username: String) -> User {
      User {
          email,
          username,
          active: true,
          sign_in_count: 1,
      }
  }
#+end_src

*** Creating Instances From Other Instances With Struct Update Syntax
위 예제에 추가하여 ~user2~ 인스턴스를 더 생성하는데 특정 필드만 다르다고 가정해보자. ~user2~ 를 생성하려면 일반적으로 다음과 같이 해야할 것이다.

#+begin_src rust
  fn main() {
      // -- snip --

      let user2 = User {
          active: user1.active,
          username: user1.username,
          email: String::from("another@example.com"),
          sign_in_count: user1.sign_in_count,
      };
  }
#+end_src

~user1~ 인스턴스와는 email 필드만 다른 ~user2~ 인스턴스가 생성되었다. 이것을 다음과 같이 단순하게 표현할 수 있다.

#+begin_src rust
  fn main() {
      // -- snip --

      let user2 = User {
          email: String::from("another@example.com"),
          ..user1
      };
  }
#+end_src


*** 필드가 없는 구조체
필드가 없는 구조체를 정의할 수 있는데, 이것을 /unit-like structs/ 라고 한다. 이것은 ~()~ 와 비슷하게 행동한다.

#+begin_src rust
  struct AlwaysEqual;

  fn main() {
      let subject = AlwaysEqual;
  }
#+end_src

*** 메서드

메서드는 ~impl~ 문을 이용하여 구조체 맥락 내에서 정의한다.

#+begin_src rust :results output :exports both
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }

  impl Rectangle {
      fn area(&self) -> u32 {
          self.width * self.height
      }
  }

  fn main() {
      let rect1 = Rectangle {
          width: 30,
          height: 50,
      };

      println!(
          "The area of the rectangle is {} square pixels.",
          rect1.area()
      );
  }
#+end_src

#+RESULTS:
: The area of the rectangle is 1500 square pixels.

** Generic Types

#+begin_src rust :results output :exports both
  fn give_thing<T>(input: T) -> T {
      input
  }

  fn main() {
      let x = give_thing(String::from("Hello"));
      let y = give_thing(345);

      println!("{}", x);
      println!("{}", y);
  }
#+end_src

#+RESULTS:
: Hello
: 345

좀 더 실용적인 예를 든다면, 입력 받은 제네릭한 값을 출력하는 경우를 생각해볼 수 있다.

#+begin_src rust
  fn compare_and_print(statement: ???, num_1: ???, num_2: ???) {
      println!(
          "{}! Is {} greater than {}? {}", 
          statement, 
          num_1, 
          num_2, 
          num_1 > num_2
      );
  }

  fn main() {
      compare_and_print("Listen up!", 9, 8);
  }
#+end_src

#+begin_src rust :results output :exports both
  use std::cmp::PartialOrd;
  use std::fmt::Display;

  fn compare_and_print<T: Display, U: Display + PartialOrd>(statement: T, num_1: U, num_2: U) {
      println!(
	  "{}! Is {} greater than {}? {}",
	  statement,
	  num_1,
	  num_2,
	  num_1 > num_2
      );
  }

  fn main() {
      compare_and_print("Listen up!", 9, 8);
  }
#+end_src

#+RESULTS:
: Listen up!! Is 9 greater than 8? true

*팁*: ~compare_and_print~ 함수의 인자를 다음과 같이 표현할 수 도 있다.

#+begin_src rust :results output
  use std::cmp::PartialOrd;
  use std::fmt::Display;

  fn compare_and_print<T, U>(statement: T, num_1: U, num_2: U) 
  where 
        T: Display,
        U: Display + PartialOrd,
  {
      println!(
          "{}! Is {} greater than {}? {}",
          statement,
          num_1,
          num_2,
          num_1 > num_2
      );
  }

  fn main() {
      compare_and_print("Listen up!", 9, 8);
  }
#+end_src

#+RESULTS:
: Listen up!! Is 9 greater than 8? true

* Loops

** ~loop~
- ~break~ 문을 이용하여 루프를 빠져나올 수 있다.
- 루프별로 이름(tagging)을 줄 수 있다.

#+begin_src rust :results output
  #![allow(unused_labels)]
  fn main() {
      let mut i = 0;
      let mut j = 0;

      'outer: loop {
          i += 1;
          if i > 3 {
              'inner: loop {
                  j += 1;
                  if j == 3 {
                      break 'outer;
                  }
              }
          }
      }
  }
#+end_src

#+RESULTS:

** ~while~

** ~for~

* 사실들

** Immutable variables과 Constants의 차이점

- 둘 다 변하지 않는 값을 표현하는 방식이지만, Constants는 ~mut~ 을 붙여서 mutable 하게 만들 수 없음.
- Constants는 ~let~ 을 쓸 수 없고 ~const~ 를 붙이며, 해당 값의 타입은 항상 annotate 해야함.

** ~match~ 문

~switch~ 문과 비슷한 기능을 하지만 더 편리하다.

#+begin_src rust :results output :exports both
  fn main() {
      let sky = "clear";
      let temperature = "warm";

      // 다중 상태를 체크할 수 있다. 이 때는 tuple 사용.
      match (sky, temperature) {
          ("cloudy", "cold") => println!("It's a bad day."),
          ("cloudy", "warm") => println!("It's a blue day."),
          ("cloudy", _) => println!("It's a cloudy day."),
          _ => println!("Not sure what the weather is.")
      }
  }
#+end_src

#+RESULTS:
: Not sure what the weather is.

~if~ 문을 같이 쓰는 경우:

#+begin_src rust :results output :exports both
  fn main() {
      let children = 5;
      let married = true;

      match (children, married) {
          (children, married) if !married => println!("Not married with {} children", children),
          (c, m) if c == 0 && m => println!("Married with no child"),
          _ => println!("Some other type of marriage an children combination")
      }
  }
#+end_src

#+RESULTS:
: Some other type of marriage an children combination



** 언더바 '~_~'의 쓰임새

'나머지 것' 혹은 '쓰이지 않음' 등의 의미로 쓰인다.

*** ~match~ 문에서 사용예

#+begin_src rust :results output :exports both
  fn main() {

      let a_num = 9;

      match a_num {
          0 => println!("It's a zero"),
          1 => println!("It's a one"),
          _ => println!("It's an unknown number")
      }
  }
#+end_src

#+RESULTS:
: It's an unknown number

*** tuple의 item을 각 변수로 맵핑할 때

#+begin_src rust :results output :exports both
  fn main() {
      let a_tuple = ( "hello", 9292, vec![1, 2, 3]);
      let (a, _, b) = a_tuple;

      println!("a is {:?}", a);
      println!("b is {:?}", b);
  }
#+end_src

#+RESULTS:
: a is "hello"
: b is [1, 2, 3]

** 골뱅이 '~@~'의 쓰임새

뭔가 구체적으로 더 기술해야할 때 사용될 수 있다. 예를 들어 ~match~ 문에서:

#+begin_src rust :results output :exports both
  fn match_number(input: i32) {
      match input {
          number @ 0..=10 => println!("It's between 0 and 10. It's the number {}", number),
          _ => println!("It's greater than ten" )
      }
  }

  fn main() {
      match_number(10);
      match_number(23);
  }
#+end_src

#+RESULTS:
: It's between 0 and 10. It's the number 10
: It's greater than ten

** Traits

다른 언어에서 interface라 일컬어지는 것과 비슷한 면이 있다. [[https://doc.rust-lang.org/book/ch10-02-traits.html][책]]참고.

* Projects

** [[https://github.com/sharkdp/bat.git][bat]]

** [[https://github.com/ClementTsang/bottom][bottom]]

** [[https://github.com/ogham/dog][dog]]

** [[https://github.com/bootandy/dust][dust]]

** [[https://github.com/ogham/exa][exa]]

* See Also
- [[https://doc.rust-lang.org/][Rust Documentations]] ([[https://doc.rust-lang.org/std/index.html][Standard Library References]])
- [[https://play.rust-lang.org/][Rust Playground]]
- [[https://dhghomon.github.io/easy_rust/][Easy Rust]] ([[https://github.com/Dhghomon/easy_rust][github]], [[https://www.youtube.com/watch?v=W9DO6m8JSSs&list=PLfllocyHVgsSJf1zO6k6o3SX2mbZjAqYE][youtube 한국어]])

