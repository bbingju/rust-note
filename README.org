#+TITLE: Rust Note
#+AUTHOR: Phil Hwang
#+EMAIL: pjhwang@gmail.com

#+SETUPFILE: theme-readtheorg.setup
#+STARTUP: show2levels

#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]
#+LATEX_HEADER: \usepackage{kotex}
#+LATEX_HEADER: \usepackage{a4wide}
#+LATEX_HEADER: \usepackage{listings}
# #+LATEX_HEADER: \usepackage{minted}
# #+LaTeX_HEADER: \setmainhangulfont{HCR Batang LVT}
#+LATEX_HEADER: \setmainhangulfont{Noto Sans CJK KR}

* 개발환경

- 간단한 코드 테스트는 [[https://play.rust-lang.org/][Rust Playground]]에서 할 수 있다.
- 프로그래밍에 필요한 여러 부가정보는 [[https://forge.rust-lang.org/index.html][Rust Forge]]에서 확인할 수 있다.

** Toolchains

*** Command Line Tools

유닉스 계열 운영체제는 다음과 같이 [[https://static.rust-lang.org/rustup/rustup-init.sh][rustup-init.sh]] 스크립트를 내려받은 후 실행시켜 설치할 수 있다.

#+ATTR_LATEX: :options frame=single
#+begin_src shell
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
#+end_src

이 방법으로 플랫폼에 맞는 =rustup= 명령을 설치할 수 있다. =rustup= 은 일종의 패키지 매니저이며, 이것을 통해 실제 Rust용 툴체인들을 설치할 수 있다.

**** =rustup=

설치된 패키지들을 업데이트하려면 다음과 같이 명령한다.

#+begin_src shell :results output :exports both :options frame=single
  rustup update
#+end_src

#+RESULTS:
: 
:   stable-x86_64-unknown-linux-gnu unchanged - rustc 1.65.0 (897e37553 2022-11-02)
: 


로컬로 문서를 보고 싶다면 다음과 같이 명령한다.

#+begin_src shell
  rustup doc
#+end_src

#+RESULTS:

** Editors

*** Emacs

Emacs로 Rust 언어를 프로그래밍 하는 기본적인 방법은 [[https://github.com/rust-lang/rust-mode][rust-mode]] 을 설치하는 것이다. 필요할 경우, [[https://emacs-lsp.github.io/lsp-mode/page/lsp-rust-analyzer/][LSP Mode]]나 [[https://emacs-tree-sitter.github.io/][tree-sitter]]를 고민해 볼 수 있다.

* Data Types

- Scalar와 compound로 나뉨.
- Scalar는 한개짜리 값을 의미하는데, integers, floating-point numbers, Booleans, 문자열이 여기에 속함.
- Integer type에 ~isize~, ~usize~ 라는 것이 있음.
- Integer literal은 다음과 같이 표기함

  #+NAME: Integer Literals in Rust
  | Number literals  | Example       |
  |------------------+---------------|
  | Decimal          | =98_222=      |
  | Hex              | =0xff=        |
  | Octal            | =0o77=        |
  | Binary           | =0b1111_0000= |
  | Byte (~u8~ only) | =b'A'=        |


** Tuple

Tuple은 괄호'~()~'를 사용한다.

#+begin_src rust results: output :exports both
  fn main() {
      let empty_tuple = ();		// 빈 투플
      let my_tuple = ( 23, "test tuple", vec![34, 23, 9] );

      println!("empty tuple: {:?}, my_tuple.0: {:}, my_tuple.1: {:?}",
               empty_tuple, my_tuple.0, my_tuple.1);
  }

#+end_src

#+RESULTS:
: empty tuple: (), my_tuple.0: 23, my_tuple.1: "test tuple"

* 사실들

** Immutable variables과 Constants의 차이점

- 둘 다 변하지 않는 값을 표현하는 방식이지만, Constants는 ~mut~ 을 붙여서 mutable 하게 만들 수 없음.
- Constants는 ~let~ 을 쓸 수 없고 ~const~ 를 붙이며, 해당 값의 타입은 항상 annotate 해야함.

** ~match~ 문

~switch~ 문과 비슷한 기능을 하지만 더 편리하다.

#+begin_src rust :results output :exports both
  fn main() {
      let sky = "clear";
      let temperature = "warm";

      // 다중 상태를 체크할 수 있다. 이 때는 tuple 사용.
      match (sky, temperature) {
          ("cloudy", "cold") => println!("It's a bad day."),
          ("cloudy", "warm") => println!("It's a blue day."),
          ("cloudy", _) => println!("It's a cloudy day."),
          _ => println!("Not sure what the weather is.")
      }
  }
#+end_src

#+RESULTS:
: Not sure what the weather is.

~if~ 문을 같이 쓰는 경우:

#+begin_src rust :results output :exports both
  fn main() {
      let children = 5;
      let married = true;

      match (children, married) {
          (children, married) if !married => println!("Not married with {} children", children),
          (c, m) if c == 0 && m => println!("Married with no child"),
          _ => println!("Some other type of marriage an children combination")
      }
  }
#+end_src

#+RESULTS:
: Some other type of marriage an children combination



** 언더바 '~_~'의 쓰임새

'나머지 것' 혹은 '쓰이지 않음' 등의 의미로 쓰인다.

*** ~match~ 문에서 사용예

#+begin_src rust :results output :exports both
  fn main() {

      let a_num = 9;

      match a_num {
          0 => println!("It's a zero"),
          1 => println!("It's a one"),
          _ => println!("It's an unknown number")
      }
  }
#+end_src

#+RESULTS:
: It's an unknown number

*** tuple의 item을 각 변수로 맵핑할 때

#+begin_src rust :results output :exports both
  fn main() {
      let a_tuple = ( "hello", 9292, vec![1, 2, 3]);
      let (a, _, b) = a_tuple;

      println!("a is {:?}", a);
      println!("b is {:?}", b);
  }
#+end_src

#+RESULTS:
: a is "hello"
: b is [1, 2, 3]

** 골뱅이 '~@~'의 쓰임새

뭔가 구체적으로 더 기술해야할 때 사용될 수 있다. 예를 들어 ~match~ 문에서:

#+begin_src rust :results output :exports both
  fn match_number(input: i32) {
      match input {
          number @ 0..=10 => println!("It's between 0 and 10. It's the number {}", number),
          _ => println!("It's greater than ten" )
      }
  }

  fn main() {
      match_number(10);
      match_number(23);
  }
#+end_src

#+RESULTS:
: It's between 0 and 10. It's the number 10
: It's greater than ten

** Traits

다른 언어에서 interface라 일컬어지는 것과 비슷한 면이 있다. [[https://doc.rust-lang.org/book/ch10-02-traits.html][책]]참고.

* Projects

** [[https://github.com/sharkdp/bat.git][bat]]

** [[https://github.com/ClementTsang/bottom][bottom]]

** [[https://github.com/ogham/dog][dog]]

** [[https://github.com/bootandy/dust][dust]]

** [[https://github.com/ogham/exa][exa]]

* See Also
- [[https://doc.rust-lang.org/][Rust Documentations]] ([[https://doc.rust-lang.org/std/index.html][Standard Library References]])
- [[https://play.rust-lang.org/][Rust Playground]]
- [[https://dhghomon.github.io/easy_rust/][Easy Rust]] ([[https://github.com/Dhghomon/easy_rust][github]], [[https://www.youtube.com/watch?v=W9DO6m8JSSs&list=PLfllocyHVgsSJf1zO6k6o3SX2mbZjAqYE][youtube 한국어]])

